<!DOCTYPE html>
<html>

<head>
    <style>
        .list-container {
            position: relative;
            height: 100%;
        }

        .list-background {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: var(--main-image);
            background-position: bottom;
            background-repeat: no-repeat;
            background-size: cover;
            filter: var(--main-filter);
        }

        .list-content {
            position: relative;
            height: 100%;
            overflow-y: auto;
        }

        /* Width */
        ::-webkit-scrollbar {
            width: 6px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: var(--clr-bground);
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: var(--clr-btn-norm);
        }
    </style>

    <script>
        //TODO: Сейчас вызывается только один раз! Сделать возможность удаления старого контента
        //Чтобы обновить инфу (без удаления старого), вызывающая функция должна заполмнить связку 
        //data<->item, и при изменении data, обновлять соответсвующий item

        const partSize = 25;
        const sizeRatio = 4;
        const deltaSize = 500; //Bottom marging of list + border must be < deltaSize

        const items = [];

        let fillFn;
        let loadedFrom = 0;
        let loadedTo = -1;
        let sampleElem;

        const getItemFunc = (item, ind) => zxContr => {

            item.zxContr = zxContr;
            fillFn(item.data, ind, zxContr);
        };

        const normalize = p => p < 0 ? 0 :
            p > items.length - 1 ? items.length - 1 : p;

        const createPart = (fr, to, pos) => {

            console.log('[CREATE] fr: ', fr, ' to: ', to);

            fr = normalize(fr);
            to = normalize(to);

            for (let i = fr; i <= to; i++)
                zxBase.copy(sampleElem.getId(), getItemFunc(items[i], i), pos++);

            if (to > loadedTo)
                loadedTo = to;
            else
                loadedFrom = fr;
        };

        const freePart = (fr, to) => {

            console.log('[FREE]   fr: ', fr, ' to: ', to);

            fr = normalize(fr);
            to = normalize(to);

            for (let i = fr; i <= to; i++) {

                //TODO: Надо удалять все дочерние контролы!
                items[i].zxContr.free();
                items[i].zxContr = null;
            }

            if (fr === loadedFrom)
                loadedFrom = to + 1;
            else
                loadedTo = fr - 1;
        };

        const isMaxExceeded = () => items.filter(it => !!it.zxContr).length > partSize * sizeRatio;

        const log = direct => console.log('[' + direct + ']', 'loaded:', loadedTo - loadedFrom + 1,
            'loadedFr: ', loadedFrom, 'loadedTo: ', loadedTo);

        const loadDown = () => {

            //All is loaded
            if (loadedTo >= items.length - 1) return;

            if (isMaxExceeded())
                freePart(loadedFrom, loadedFrom + partSize - 1);

            createPart(loadedTo + 1, loadedTo + partSize);
            log('DOWN');
        };

        const loadUp = () => {

            //All is loaded
            if (loadedFrom === 0) return;

            if (isMaxExceeded())
                freePart(loadedTo - partSize + 1, loadedTo);

            //Save scroll position
            const rootEl = zxBase.getHTML().children[1];
            const curScrollPos = rootEl.scrollTop;
            const oldScroll = rootEl.scrollHeight - rootEl.clientHeight;

            createPart(loadedFrom - partSize, loadedFrom - 1, 0);

            //Restore scroll position            
            const newScroll = rootEl.scrollHeight - rootEl.clientHeight;
            rootEl.scrollTop = curScrollPos + (newScroll - oldScroll);

            log('UP');
        };

        zxBase.setInitHandler(() => {

            const rElem = zxBase.getHTML().children[1];

            rElem.addEventListener('scroll', () => {

                if (rElem.scrollTop + rElem.clientHeight > rElem.scrollHeight - deltaSize)
                    loadDown();
                else if (rElem.scrollTop <= deltaSize)
                    loadUp();
            });
        });

        zxBase.setContent = (dt, fn) => {

            fillFn = fn;

            dt.forEach(d => items.push(Object.seal({
                data: d,
                zxContr: null
            })));

            sampleElem = zxBase.getAll()[0];
            sampleElem.hide();

            loadDown();
        };
    </script>
</head>

<body>
    <div class="list-container">
        <div class="list-background"></div>
        <div class="list-content">
            <z-slot>{content}</z-slot>
        </div>
    </div>
</body>

</html>